import {
  getFromAsyncStorage,
  Keys,
  saveToAsyncStorage,
} from "@/utils/asyncStorage";
import client from "./client";
import { toast } from "@backpackapp-io/react-native-toast";
import axios from "axios";
import { FormikHelpers } from "formik";
import {
  updateBusyState,
  updateLoggedInState,
  updateProfile,
} from "@/utils/store/auth";
import { useDispatch } from "react-redux";
import { Dispatch, SetStateAction } from "react";
import { ImageSourcePropType } from "react-native";
import {
  avatarPlaceholder,
  flashcardPlaceholder,
  playlistPlaceholder,
} from "@/constants/Styles";
import {
  updateBusyStateCollection,
  updateCollectionData,
  updateCollectionId,
} from "@/utils/store/Collection";
import { collectionInfoSchema, FromFields } from "@/@types/reuseables";

interface FetchRecentlyPlayedProps {
  setRecentlyPlayedData: (data: any) => void;
  setError: (error: string) => void;
  setLoading: (loading: boolean) => void;
}
interface FetchAutogeneratedProps {
  setError: (error: string) => void;
  setLoading: (loading: boolean) => void;
  setAutogeneratedPlaylist: (data: any) => void;
}
interface FetchSuggestedCollections {
  setError: (error: string) => void;
  setLoading: (loading: boolean) => void;
  setSuggestedCollections: (data: any) => void;
}
interface FetchFavorites {
  setError: (error: string) => void;
  setLoading: (loading: boolean) => void;
  setFavorites: (data: any) => void;
}

export const getAutogeneratedPlaylist = async (
  props: FetchAutogeneratedProps
) => {
  const { setAutogeneratedPlaylist, setError, setLoading } = props;
  try {
    const token = await getFromAsyncStorage(Keys.AUTH_TOKEN);
    if (!token) {
      throw new Error("User is not authenticated. Token is missing.");
    }
    const res = await client.get("/profile/auto-generated-playlist", {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    setAutogeneratedPlaylist(res.data.playlist);
  } catch (err) {
    setError(
      "Failed to fetch auto Generated playlist. Please try again later."
    );
    console.error("Error fetching Generated playlist", err);
  } finally {
    setLoading(false);
  }
};

export const truncateText = (text: string, maxLength: number = 20): string => {
  if (text.length <= maxLength) {
    return text;
  }
  return text.substring(0, maxLength) + "...";
};
export const formatTime = (time: string): string => {
  const date = new Date(time);
  return date.toDateString();
};
export const formatNumber = (number: number): string => {
  return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};
export const formatDuration = (duration: number): string => {
  const minutes = Math.floor(duration / 60);
  const seconds = duration % 60;
  return `${minutes}:${seconds}`;
};
export const formatViews = (views: number): string => {
  if (views < 1000) {
    return views.toString();
  }
  return `${(views / 1000).toFixed(1)}k`;
};
export const formatFollowers = (followers: number): string => {
  if (followers < 1000) {
    return followers.toString();
  }
  if (!followers) return "0";
  return `${(followers / 1000).toFixed(1)}k`;
};

// here ends Favorites.tsx
export const handleError = (err: unknown) => {
  if (axios.isAxiosError(err)) {
    // Server responded with a status other than 200 range
    if (err.response?.status === 401 || err.response?.status === 403) {
      const errorMessage = err.response?.data?.message || err.message;
      toast.error(`${errorMessage}` ,{ icon: "❌" });
      console.log("handle err", err);
    } else if (err.response?.status === 422) {
      toast.error("Unprocessable Entity: Please check your input data ", {
        icon: "❌",
      });
    } else {
      const errorMessage = err.response?.data?.message || err.message;
      toast.error(`Error: ${errorMessage} ❌`);
    }
  } else if (err instanceof Error && err.message) {
    // Something else happened while setting up the request
    toast.error(`Error: ${err.message} ❌`);
  } else {
    // Unknown error
    toast.error("An unknown error occurred ❌");
  }
};

interface UseLoadDataProps<T> {
  refetch: () => Promise<void>;
  data: T | undefined;
  setData: (data: T) => void;
  setLoading: (loading: boolean) => void;
  setError: (error?: string) => void;
  storageKey: string;
  dataName: string; // Descriptive name for logging
  handleError: (err: any) => void;
}

export const useLoadData = <T>({
  refetch,
  data,
  setData,
  setLoading,
  setError,
  storageKey,
  dataName,
}: UseLoadDataProps<T>) => {
  const loadData = async () => {
    setLoading(true);
    setError();

    try {
      // 1. Try to fetch data from the API
      await refetch(); // Trigger a refetch to get the latest data

      if (
        data &&
        (Array.isArray(data) ? data.length > 0 : Object.keys(data).length > 0)
      ) {
        // 2. If API data is available, update state and AsyncStorage
        setData(data);
        await saveToAsyncStorage(storageKey, JSON.stringify(data));
        console.log(`${dataName} updated from API`);
      } else {
        // 3. If API data is unavailable, try to load from AsyncStorage
        const storedData = await getFromAsyncStorage(storageKey);

        if (storedData) {
          try {
            const parsedData: T = JSON.parse(storedData);
            setData(parsedData);
            console.log(`${dataName} loaded from AsyncStorage`);
          } catch (parseError) {
            console.error(
              `Error parsing ${dataName} from AsyncStorage:`,
              parseError
            );
            setError(`Error loading stored ${dataName}. Please try again.`);
          }
        } else {
          // 4. If both API and AsyncStorage data are unavailable, set an error
          setError(`Failed to load ${dataName}. Please try again later.`);
          console.log(`No ${dataName} data available.`);
        }
      }
    } catch (err) {
      // Handle errors during API fetch or AsyncStorage operations
      setError(`Failed to load ${dataName}. Please try again later.`);
      console.error(`Error loading ${dataName}:`, err);
    } finally {
      setLoading(false);
    }
  };

  return loadData;
};

export const formatRelativeTime = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diff = now.getTime() - date.getTime();
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  const months = Math.floor(days / 30);
  const years = Math.floor(months / 12);

  if (years > 0) {
    return `${years} year${years > 1 ? "s" : ""} ago`;
  } else if (months > 0) {
    return `${months} month${months > 1 ? "s" : ""} ago`;
  } else if (days > 0) {
    return `${days} day${days > 1 ? "s" : ""} ago`;
  } else if (hours > 0) {
    return `${hours} hour${hours > 1 ? "s" : ""} ago`;
  } else if (minutes > 0) {
    return `${minutes} minute${minutes > 1 ? "s" : ""} ago`;
  } else {
    return "Just now";
  }
};

export const formatLikes = (likes: number): string => {
  if (likes < 1000) {
    return likes.toString();
  } else if (likes < 1000000) {
    return (likes / 1000).toFixed(1) + "K";
  } else if (likes < 1000000000) {
    return (likes / 1000000).toFixed(1) + "M";
  } else {
    return (likes / 1000000000).toFixed(1) + "B";
  }
};

// get image or replace with placeholder
export const getSource = (
  poster?: string,
  placeholder: ImageSourcePropType = flashcardPlaceholder ||
    playlistPlaceholder ||
    avatarPlaceholder
): ImageSourcePropType => {
  return poster ? { uri: poster } : placeholder;
};
